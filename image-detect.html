<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Logo Composer — Kunsthaus Zürich</title>
    <link rel="stylesheet" href="style.css">
</head>
<style>
    svg {
        background-color: transparent !important;
    }
</style>

<body>
    <img id="bg" alt="" />
    <input id="file" type="file" accept="image/*" hidden />

    <div class="wrap">
        <div class="ui" style="position: absolute; z-index: 10; display: none;">
            <div class="card">
                <div class="row mono" id="msg">—</div>
            </div>
            <div class="card mono">
                <div class="row">求解的 <b>hx</b>：<span id="hx">—</span></div>
                <div class="row">新的 <b>Width</b>：<span id="width">—</span></div>
                <div class="row">分母检查：<span id="den">—</span></div>
                <hr>
                <div class="row"><b>公式回算</b> W/H：<span id="wh">—</span>，相对误差：<span id="err1">—</span></div>
                <div class="row"><b>投影实测</b> W/H：<span id="wh2">—</span>，相对误差：<span id="err2">—</span></div>
                <div class="row legend">
                    <span><i class="greenDot"></i>目标 AABB（同中心、同 H，W=t·H）</span>
                    <span><i class="orangeDot"></i>实际 AABB（投影角点）</span>
                </div>
            </div>
        </div>

        <div class="stage">
            <canvas id="overlay"
                style="position:absolute;left:0;top:0;pointer-events:none; background: transparent;"></canvas>
        </div>
    </div>

    <script type="importmap">
			{
				"imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.125.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.125.0/examples/jsm/"
				}
			}
		</script>

    <script type="module">
        import * as THREE from 'three';
        import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        import { saveCurrentSVG, startCanvasRecording } from './export.js';

        let kGroup;
        let strip1, strip2, strip3;
        let targetCtrl, yawCtrl, pitchCtrl;
        let info;
        
        let TARGET_W_PX = 600;

        const el = id => document.getElementById(id);
        function parseRatio(str) {
            str = String(str).trim();
            if (!str) return NaN;
            if (str.includes(':')) {
                const [a, b] = str.split(':').map(Number);
                if (isFinite(a) && isFinite(b) && b !== 0) return a / b;
                return NaN;
            } else {
                const v = Number(str);
                return isFinite(v) ? v : NaN;
            }
        }

        const hxOut = el('hx');
        const widthOut = el('width');
        const denOut = el('den');
        const whOut = el('wh');
        const err1Out = el('err1');
        const wh2Out = el('wh2');
        const err2Out = el('err2');
        const msg = el('msg');

        const baseDims = { w: 4, h: 2, d: 2 };

        const boxParams = {
            kStroke: 0.2,
            width: baseDims.w,
            height: baseDims.h,
            depth: baseDims.d
        };

        const colorParams = {
            bg: '#000000',
            cStroke: '#000000',
        };

        const strokeMats = new Set();

        function trackStrokeMaterial(mat) {
            // tag & set initial color
            if (mat && mat.color) mat.color.set(colorParams.cStroke);
            strokeMats.add(mat);
            return mat; // so you can inline it
        }

        function setStrokeColor(v) {
            strokeMats.forEach((mat) => {
                if (!mat) return;
                if (Array.isArray(mat)) {
                    mat.forEach(m => m?.color?.set(v));
                } else {
                    mat.color?.set(v);
                }
            });
            render();
        }

        const matWhiteDS = trackStrokeMaterial(
            new THREE.MeshBasicMaterial({ color: colorParams.cStroke, side: THREE.DoubleSide })
        );
        const matLine = trackStrokeMaterial(
            new THREE.LineBasicMaterial({ color: colorParams.cStroke })
        );


        const AABBParams = {
            targetRatio: "1:1",
            pitch: 15,
            yaw: 30,
            animation: true,
            duration: 1,
            applyAndSolve: applyAndSolve,
            randomAndSolve: randomAndSolve
        }
        const svgParams = {
            filename: 'logo.svg',
            background: true,
            save: () => (switchRenderer("SVG (SVG Output)"), render(), saveCurrentSVG(renderer.domElement, svgParams.filename, svgParams.background)),
        };

        const recParams = {
            seconds: AABBParams.duration || 5,
            fps: 60,
            filename: 'capture.webm',
            matte: '#00ff00'
        };

        function makeCopyCanvas({ matte = recParams.matte } = {}) {
            const src = renderer.domElement;

            const dst = document.createElement('canvas');
            dst.width = src.width;
            dst.height = src.height;
            Object.assign(dst.style, {
                position: 'absolute', top: '100vh'
            });
            document.body.appendChild(dst);

            const dctx = dst.getContext('2d');

            function frame() {
                renderer.render(scene, camera);  // draw Three.js
                dctx.fillStyle = matte;         // matte
                dctx.fillRect(0, 0, dst.width, dst.height);
                dctx.drawImage(src, 0, 0);       // copy this frame
                requestAnimationFrame(frame);
            }
            frame();

            return { canvas: dst };
        }

        const recordActions = {
            startRecord() {
                switchRenderer("WebGL (Video Output)");

                const { canvas: copyCanvas } = makeCopyCanvas(); // <— keep reference

                startCanvasRecording(renderer, {
                    seconds: recParams.seconds,
                    fps: recParams.fps,
                    filename: recParams.filename,
                    canvas: copyCanvas                 // <— pass the copy canvas here
                });
            }
        };

        const comboActions = {
            startAnimRecord() {
                applyAndSolve();
                recordActions.startRecord();
            }
        };

        const overlay = document.getElementById('overlay');
        let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });//SVGRenderer();

        const al = renderer.domElement;

        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.traverse(o => o.layers.enable(0));

        let lastMeasuredRect = null;
        let lastTargetWH = null;

        function setSize() {
            const cssW = window.innerWidth;
            const cssH = window.innerHeight;
            const dpr = Math.min(window.devicePixelRatio || 1, 2);

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            overlay.style.width = cssW + 'px';
            overlay.style.height = cssH + 'px';
            overlay.width = Math.round(cssW * dpr);
            overlay.height = Math.round(cssH * dpr);

            if (lastMeasuredRect) {
                drawAABBs(lastTargetWH, lastMeasuredRect);
            }
        }
        const frustumHeight = 8;
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(
            -frustumHeight * aspect / 2,
            frustumHeight * aspect / 2,
            frustumHeight / 2,
            -frustumHeight / 2,
            -100, 100
        );

        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.top = frustumHeight / 2;
            camera.bottom = -frustumHeight / 2;
            camera.left = -frustumHeight * aspect / 2;
            camera.right = frustumHeight * aspect / 2;
            camera.updateProjectionMatrix();
        }


        let poseGroup = new THREE.Group();
        scene.add(poseGroup);

        const geo = new THREE.BoxGeometry(4, 2, 2); // Width=4, Height=2, Depth=2
        geo.computeBoundingBox();
        const mat = new THREE.MeshNormalMaterial({ wireframe: true, opacity: 0, transparent: true });
        const mesh = new THREE.Mesh(geo, mat);
        const box = new THREE.BoxHelper(mesh, colorParams.cStroke);
        box.matrixAutoUpdate = true;
        mesh.add(box);
        poseGroup.add(mesh);


        // 3D 里渲染一个包围盒辅助线（会随 mesh 变化自动更新一次）
        const worldBox = new THREE.Box3().setFromObject(mesh);
        const boxHelper = new THREE.Box3Helper(worldBox, "red"); // 橙色
        boxHelper.name = "Box3Helper";
        scene.add(boxHelper);

        class Box3HelperDashed extends THREE.LineSegments {

            constructor(box, color = 0xff0000) {
                let baseLines = [
                    new THREE.Vector3(1, 1, 1),
                    new THREE.Vector3(1, 1, -1),
                    new THREE.Vector3(1, 1, -1),
                    new THREE.Vector3(1, -1, -1),
                    new THREE.Vector3(1, -1, -1),
                    new THREE.Vector3(1, -1, 1)
                ]
                let axis = new THREE.Vector3(0, 1, 0);
                let pts = [];
                for (let i = 0; i < 4; i++) {
                    baseLines.forEach(bl => {
                        pts.push(bl.clone().applyAxisAngle(axis, Math.PI * 0.5 * i));
                    })
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(pts);
                super(geometry, new THREE.LineDashedMaterial({ color: color, toneMapped: false, dashSize: 0.01, gapSize: 0.02 }));

                this.box = box;
                this.type = 'Box3HelperDashed';
                this.geometry.computeBoundingSphere();
                this.computeLineDistances();
            }

            updateMatrixWorld(force) {
                const box = this.box;
                if (box.isEmpty()) return;
                box.getCenter(this.position);
                box.getSize(this.scale);
                this.scale.multiplyScalar(0.5);
                super.updateMatrixWorld(force);
            }
        }

        let sphere = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: "red", wireframe: true }));
        let b3 = new THREE.Box3().setFromObject(sphere);
        let dashedHelper = new Box3HelperDashed(worldBox);
        //scene.add(dashedHelper);

        function render() {
            renderer.render(scene, camera);
            // setupDashClassOnSvg(renderer.domElement);
        }

        window.addEventListener('resize', () => {
            setSize();
            updateCamera();
            render();
        });

        setSize();
        updateCamera();

        function deg2rad(d) { return d * Math.PI / 180; }

        function getAbsR01(obj) {
            const q = new THREE.Quaternion();
            obj.getWorldQuaternion(q);
            const m = new THREE.Matrix4().makeRotationFromQuaternion(q);
            const e = m.elements; // 列主序
            const a00 = Math.abs(e[0]);  // R00
            const a01 = Math.abs(e[4]);  // R01
            const a02 = Math.abs(e[8]);  // R02
            const a10 = Math.abs(e[1]);  // R10
            const a11 = Math.abs(e[5]);  // R11
            const a12 = Math.abs(e[9]);  // R12
            return { a00, a01, a02, a10, a11, a12 };
        }
        function solveHxForWH(t, R) {
            const hy = 1, hz = 1;
            const { a00, a01, a02, a10, a11, a12 } = R;
            const A = a01 * hy + a02 * hz;
            const B = a11 * hy + a12 * hz;
            const denom = (a00 - t * a10);
            return { hx: (t * B - A) / denom, A, B, denom };
        }
        function recomputeWH_byFormula(hx, R) {
            const hy = 1, hz = 1;
            const { a00, a01, a02, a10, a11, a12 } = R;
            const A = a01 * hy + a02 * hz;
            const B = a11 * hy + a12 * hz;
            const W = 2 * (a00 * hx + A);
            const H = 2 * (a10 * hx + B);
            return W / H;
        }
        function measuredAABB_byProjection(hx) {
            const hy = 1, hz = 1;
            const corners = [
                new THREE.Vector3(hx, hy, hz),
                new THREE.Vector3(hx, hy, -hz),
                new THREE.Vector3(hx, -hy, hz),
                new THREE.Vector3(hx, -hy, -hz),
                new THREE.Vector3(-hx, hy, hz),
                new THREE.Vector3(-hx, hy, -hz),
                new THREE.Vector3(-hx, -hy, hz),
                new THREE.Vector3(-hx, -hy, -hz),
            ];
            const m = mesh.matrixWorld.clone();
            const v = new THREE.Vector3();

            let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
            for (const p of corners) {
                v.copy(p).applyMatrix4(m).project(camera);
                if (v.x < minX) minX = v.x; if (v.x > maxX) maxX = v.x;
                if (v.y < minY) minY = v.y; if (v.y > maxY) maxY = v.y;
            }
            // NDC (-1..1) → 像素
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const Wpx = overlay.width;  // 已乘 dpr
            const Hpx = overlay.height;
            const toPx = (x_ndc, W) => (x_ndc * 0.5 + 0.5) * W;
            const x0 = toPx(minX, Wpx), x1 = toPx(maxX, Wpx);
            const y0 = toPx(1 - (maxY * 0.5 + 0.5) * 2 + 1, Hpx); // 直接算下面会更直观
            // 更直接：NDC→像素：px = (x*0.5+0.5)*W；py = (1-(y*0.5+0.5))*H
            const toPy = (y_ndc, H) => (1 - (y_ndc * 0.5 + 0.5)) * H;
            const yMinPx = toPy(minY, Hpx), yMaxPx = toPy(maxY, Hpx);

            const rect = {
                x: x0, y: yMaxPx, w: (x1 - x0), h: (yMinPx - yMaxPx)
            };
            const wh = (x1 - x0) / (yMinPx - yMaxPx);
            return { rect, wh, center: { x: (x0 + x1) / 2, y: (yMaxPx + yMinPx) / 2 } };
        }

        function drawAABBs(targetWH, measuredRect) {
            lastTargetWH = targetWH;
            lastMeasuredRect = measuredRect;

            const ctx = overlay.getContext('2d');
            const dpr = Math.min(window.devicePixelRatio || 1, 2);

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            // 目标 AABB：与实测同中心、同 H，W = t * H
            const H = measuredRect.h;
            const W = targetWH * H;
            const cx = measuredRect.x + measuredRect.w / 2;
            const cy = measuredRect.y + measuredRect.h / 2;
            const x = cx - W / 2;
            const y = cy - H / 2;

            ctx.setLineDash([]);
            ctx.strokeStyle = '#0a7a35';
            ctx.strokeRect(x, y, W, H);
            console.log('draw target AABB', { x, y, W, H });

            ctx.beginPath();
            ctx.arc(95, 50, 40, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function randomV() {
            const ranges = [
                { min: -170, max: -100 },
                { min: -80, max: -10 },
                { min: 10, max: 80 },
                { min: 100, max: 170 },
            ];
            const specials = [0, 90, 180];

            const wRange = 0.90 / ranges.length;    // 0.225 each
            const wSpec = 0.10 / specials.length;  // ~0.03333 each

            const buckets = [
                ...ranges.map(r => ({ type: 'range', r, w: wRange })),
                ...specials.map(v => ({ type: 'value', v, w: wSpec })),
            ];

            // weighted pick
            const r = Math.random();
            let acc = 0;
            for (const b of buckets) {
                acc += b.w;
                if (r < acc) {
                    if (b.type === 'range') {
                        const { min, max } = b.r;
                        return min + Math.random() * (max - min);
                    } else {
                        return b.v; // exact 0 / 90 / 180
                    }
                }
            }
            // fallback (floating point edge)
            return specials[specials.length - 1];
        }


        function randomYawPitch() {
            AABBParams.yaw = randomV();
            AABBParams.pitch = randomV();
            if (yawCtrl) yawCtrl.updateDisplay();
            if (pitchCtrl) pitchCtrl.updateDisplay();
        }

        function fitCameraToBox(box, camera, margin = 1.2) {
            const size = new THREE.Vector3();
            box.getSize(size); // 得到包围盒宽高深（世界空间）

            // 只需要考虑 X 和 Y（因为相机朝 Z 看）
            const boxWidth = size.x;
            const boxHeight = size.y;

            const aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
            const boxAspect = boxWidth / boxHeight;

            let viewHeight;
            if (boxAspect > aspect) {
                // 盒子更扁 → 按宽度适配
                viewHeight = boxWidth / aspect;
            } else {
                // 盒子更高 → 按高度适配
                viewHeight = boxHeight;
            }
            viewHeight *= margin; // 加点 margin，避免顶边

            camera.top = viewHeight / 2;
            camera.bottom = -viewHeight / 2;
            camera.left = -viewHeight * aspect / 2;
            camera.right = viewHeight * aspect / 2;
            camera.updateProjectionMatrix();
        }

        // 用 Box3 + 投影到 NDC → 像素，得到屏幕 AABB 宽度（px）
        function measureAABBWidthPx(box3, camera, overlayCanvas) {
            const { min, max } = box3;
            const corners = [
                new THREE.Vector3(min.x, min.y, min.z),
                new THREE.Vector3(min.x, min.y, max.z),
                new THREE.Vector3(min.x, max.y, min.z),
                new THREE.Vector3(min.x, max.y, max.z),
                new THREE.Vector3(max.x, min.y, min.z),
                new THREE.Vector3(max.x, min.y, max.z),
                new THREE.Vector3(max.x, max.y, min.z),
                new THREE.Vector3(max.x, max.y, max.z),
            ];
            const v = new THREE.Vector3();

            let minX = +Infinity, maxX = -Infinity;
            for (const p of corners) {
                v.copy(p).project(camera); // NDC [-1,1]
                if (v.x < minX) minX = v.x;
                if (v.x > maxX) maxX = v.x;
            }

            // NDC → 像素（overlay.width/height 已含 dpr）
            const Wpx = overlayCanvas.width;
            const xToPx = xNdc => (xNdc * 0.5 + 0.5) * Wpx;
            const x0 = xToPx(minX), x1 = xToPx(maxX);
            return (x1 - x0); // 屏幕 AABB 宽度（像素）
        }

        // 利用 Box3 + 投影到 overlay，得到屏幕像素矩形（你之前已有的函数）
        function measuredAABB_fromBox3_toOverlay(box3, camera, overlayCanvas) {
            const { min, max } = box3;
            const corners = [
                new THREE.Vector3(min.x, min.y, min.z),
                new THREE.Vector3(min.x, min.y, max.z),
                new THREE.Vector3(min.x, max.y, min.z),
                new THREE.Vector3(min.x, max.y, max.z),
                new THREE.Vector3(max.x, min.y, min.z),
                new THREE.Vector3(max.x, min.y, max.z),
                new THREE.Vector3(max.x, max.y, min.z),
                new THREE.Vector3(max.x, max.y, max.z),
            ];

            let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
            const v = new THREE.Vector3();

            const W = overlayCanvas.width;   // device pixels (已乘 dpr)
            const H = overlayCanvas.height;

            const toPxX = xNdc => (xNdc * 0.5 + 0.5) * W;
            const toPxY = yNdc => (1 - (yNdc * 0.5 + 0.5)) * H;

            for (const p of corners) {
                v.copy(p).project(camera);
                if (v.x < minX) minX = v.x;
                if (v.x > maxX) maxX = v.x;
                if (v.y < minY) minY = v.y;
                if (v.y > maxY) maxY = v.y;
            }

            const x0 = toPxX(minX), x1 = toPxX(maxX);
            const y0 = toPxY(maxY), y1 = toPxY(minY);

            const rect = { x: x0, y: y0, w: (x1 - x0), h: (y1 - y0) };
            const wh = rect.w / rect.h;
            return { rect, wh };
        }

        // // ⭐ 关键：把相机 zoom 调到让“屏幕上 AABB 宽度 = targetPx”
        // function fitCameraAABBWidthPx({ box3, camera, overlayCanvas, targetPx, clamp = [0.1, 1000] }) {
        //     // figure out the canvas CSS->device pixel scale
        //     const dpr = overlayCanvas.width / overlayCanvas.clientWidth || window.devicePixelRatio || 1;

        //     // targetPx is in CSS px; convert to canvas/device px to match measurement units
        //     const targetPx_device = targetPx * dpr;

        //     // 1) measure current width in the SAME units as measuredAABB returns
        //     const m1 = measuredAABB_fromBox3_toOverlay(box3, camera, overlayCanvas);
        //     const w1 = m1.rect.w;               // this is in canvas/device px

        //     if (w1 <= 0 || !isFinite(w1)) return false;

        //     // 2) scale zoom
        //     const s = targetPx_device / w1;     // both device px
        //     const newZoom = THREE.MathUtils.clamp(camera.zoom * s, clamp[0], clamp[1]);
        //     if (!isFinite(newZoom) || newZoom <= 0) return false;

        //     camera.zoom = newZoom;
        //     camera.updateProjectionMatrix();

        //     // 3) re-measure
        //     const m2 = measuredAABB_fromBox3_toOverlay(box3, camera, overlayCanvas);
        //     return m2; // { rect, wh } still in device px
        // }

        // ⭐ 关键：把相机 zoom 调到让“屏幕上 AABB 宽度 = targetPx”
        function fitCameraAABBWidthPx({
            box3, camera, overlayCanvas, targetPx, clamp = [0.1, 1000], apply = true
        }) {
            // figure out the canvas CSS->device pixel scale
            const dpr = overlayCanvas.width / overlayCanvas.clientWidth || window.devicePixelRatio || 1;
            // CSS px -> device px
            const targetPx_device = targetPx * dpr;

            // 1) measure current width
            const m1 = measuredAABB_fromBox3_toOverlay(box3, camera, overlayCanvas);
            const w1 = m1.rect.w; // device px
            if (w1 <= 0 || !isFinite(w1)) return false;

            // 2) scale zoom
            const s = targetPx_device / w1;
            const newZoom = THREE.MathUtils.clamp(camera.zoom * s, clamp[0], clamp[1]);
            if (!isFinite(newZoom) || newZoom <= 0) return false;

            let m2;
            if (apply) {
                camera.zoom = newZoom;
                camera.updateProjectionMatrix();
                m2 = measuredAABB_fromBox3_toOverlay(box3, camera, overlayCanvas);
            } else {
                // 临时应用计算结果，仅用于测量，然后恢复
                const old = camera.zoom;
                camera.zoom = newZoom;
                camera.updateProjectionMatrix();
                m2 = measuredAABB_fromBox3_toOverlay(box3, camera, overlayCanvas);
                camera.zoom = old;
                camera.updateProjectionMatrix();
            }

            // 返回最终 zoom，便于外部做动画
            return Object.assign(m2, { finalZoom: newZoom });
        }

        function runPoseAndZoomAnimation({
            worldBox,
            camera,
            overlayCanvas,
            targetPx,
            clamp = [0.1, 5000],
            zoomBehavior = 'animate',   // 'animate' | 'snap' 
            startFactor = 0.5,          // used only for 'animate'
            zoomEase = (k) => k,        // optional easing for zoom
            rotationOpts = {}
        }) {
            const measured = fitCameraAABBWidthPx({
                box3: worldBox,
                camera,
                overlayCanvas,
                targetPx,
                clamp,
                apply: false
            });

            // If we can't compute final zoom, just rotate.
            if (!measured || !isFinite(measured.finalZoom) || measured.finalZoom <= 0) {
                animateRotation(rotationOpts);
                return measured;
            }

            const zEnd = measured.finalZoom;

            if (zoomBehavior === 'snap') {
                // Immediately set final zoom, then rotate.
                camera.zoom = zEnd;
                camera.updateProjectionMatrix();
                animateRotation(rotationOpts);
                return measured;
            }

            // Default: animate zoom from final * startFactor → final
            const zStart = THREE.MathUtils.clamp(zEnd * startFactor, 1e-6, 1e9);
            camera.zoom = zStart;
            camera.updateProjectionMatrix();

            animateRotation({
                ...rotationOpts,
                onFrame: (k) => {
                    const kk = zoomEase ? zoomEase(k) : k;
                    const z = THREE.MathUtils.lerp(zStart, zEnd, kk);
                    camera.zoom = z;
                    camera.updateProjectionMatrix();
                    rotationOpts.onFrame && rotationOpts.onFrame(k);
                }
            });

            return measured;
        }



        function applyAndSolve() {

            const t = parseRatio(AABBParams.targetRatio);
            const yaw = AABBParams.yaw;
            const pitch = AABBParams.pitch;
            if (!isFinite(t) || t <= 0) {
                msg.innerHTML = '<span class="err">比例无效。</span>';
                return;
            }
            mesh.rotation.set(deg2rad(pitch), deg2rad(yaw), 0, 'XYZ');
            mesh.updateMatrixWorld(true);
            const R = getAbsR01(mesh);
            const {
                hx,
                A,
                B,
                denom
            } = solveHxForWH(t, R);
            denOut.textContent = denom.toFixed(9);
            const EPS = 1e-10;
            if (Math.abs(denom) < EPS) {
                const WH_noWidth = A / B;
                const rel = Math.abs(WH_noWidth - t) / t;
                hxOut.textContent = '（任意）';
                widthOut.textContent = '（任意）';
                whOut.textContent = WH_noWidth.toFixed(9);
                err1Out.textContent = (rel * 100).toFixed(6) + '%';
                if (rel < 5e-3) {
                    msg.innerHTML = '<span class="ok">分母≈0，但该姿态本来就满足目标，无需改宽。</span>';
                } else {
                    msg.innerHTML = '<span class="warn">分母≈0 且本姿态无法通过改宽达到此比例，请换个旋转。</span>';
                }
                mesh.scale.set(1, 1, 1);
                mesh.updateMatrixWorld(true);
            } else {
                if (!(isFinite(hx) && hx > 0)) {
                    if (info) { info.setText('Error: Cannot achieve the target ratio. Try a different angle.'); info.setType('err'); }
                    return;
                }
                const width = 2 * hx;
                mesh.scale.set(hx / 2, 1, 1);
                mesh.updateMatrixWorld(true);
                const wh_formula = recomputeWH_byFormula(hx, R);
                const err1 = Math.abs(wh_formula - t) / t;
                hxOut.textContent = hx.toFixed(9);
                widthOut.textContent = width.toFixed(9);
                whOut.textContent = wh_formula.toFixed(9);
                err1Out.textContent = (err1 * 100).toFixed(6) + '%';
                const ok = err1 < 5e-3;
                if (info) {
                    info.setText(ok
                        ? 'Success'
                        : '公式回算误差 > 0.5%，请检查旋转/取值。');
                    info.setType(ok ? 'ok' : 'warn'); // 你的 addLabel 提供的类型：ok / warn / err
                }
            }
            rebuildStrips();
            mesh.updateMatrixWorld(true);
            worldBox.setFromObject(mesh);
            boxHelper.box.copy(worldBox);
            boxHelper.updateMatrixWorld(true);

            const measuredAfter = runPoseAndZoomAnimation({
                worldBox,
                camera,
                overlayCanvas: overlay,
                targetPx: TARGET_W_PX,
                startFactor: 0.5,
                clamp: [0.1, 5000],
                zoomBehavior: 'animate',
                rotationOpts: {}
            });


            if (measuredAfter) {
                wh2Out.textContent = measuredAfter.wh.toFixed(9);
                err2Out.textContent = (Math.abs(measuredAfter.wh - t) / t * 100).toFixed(6) + '%';
            }

            render();
        }

        // ---- animation state ----
        let _animRAF = null;
        let _animCancel = null;

        /** Easing（可换任意你喜欢的）：easeInOutCubic */
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function easeOutCubic(t) {
            t = Math.max(0, Math.min(1, t));
            return 1 - Math.pow(1 - t, 3);
        }

        function animateRotation({
            offsetYawDeg = -15,   // 绕世界Y的预偏移
            offsetPitchDeg = 15,   // 绕世界X的预偏移（你说“加上x旋转”就用这个）
            onFrame
        }) {
            // 取消上一个动画
            if (AABBParams.animation !== true) return;
            if (_animCancel) { _animCancel(); _animCancel = null; }
            if (_animRAF) { cancelAnimationFrame(_animRAF); _animRAF = null; }

            const startTime = performance.now();
            let stopped = false;
            _animCancel = () => { stopped = true; };

            // 终点：当前世界姿态（假设此刻就是“可行角度”）
            const qEnd = poseGroup.getWorldQuaternion(new THREE.Quaternion());

            // 预偏移：先从终点往回旋（世界Y，然后世界X；如你需要相反顺序就调换）
            const qYawOff = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(offsetYawDeg));
            const qPitchOff = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(offsetPitchDeg));

            // 起点的“世界四元数” = 偏移 * 终点
            const qStartWorld = qYawOff.multiply(qPitchOff).multiply(qEnd).normalize();

            // 如果 poseGroup 的父节点是 scene（无旋转），可直接赋值；
            // 若父节点有旋转，需要把 qStartWorld 转成局部四元数再赋值：
            if (poseGroup.parent) {
                const qParentWorld = poseGroup.parent.getWorldQuaternion(new THREE.Quaternion());
                const qParentInv = qParentWorld.invert();
                const qStartLocal = qParentInv.multiply(qStartWorld);
                poseGroup.quaternion.copy(qStartLocal);
            } else {
                poseGroup.quaternion.copy(qStartWorld);
            }
            poseGroup.updateMatrixWorld(true);

            function frame(now) {
                if (stopped) return;
                const t = Math.min(1, (now - startTime) / AABBParams.duration / 1000);
                const k = easeOutCubic ? easeOutCubic(t) : t;

                // slerp: 起点 → 终点（世界）
                const qCurWorld = new THREE.Quaternion();
                THREE.Quaternion.slerp(qStartWorld, qEnd, qCurWorld, k);

                // 写回到本地四元数
                if (poseGroup.parent) {
                    const qParentWorld2 = poseGroup.parent.getWorldQuaternion(new THREE.Quaternion());
                    const qParentInv2 = qParentWorld2.invert();
                    const qLocal = qParentInv2.multiply(qCurWorld);
                    poseGroup.quaternion.copy(qLocal);
                } else {
                    poseGroup.quaternion.copy(qCurWorld);
                }

                // 刷新 & 渲染
                poseGroup.updateMatrixWorld(true);
                worldBox.setFromObject(poseGroup);
                boxHelper.box.copy(worldBox);
                boxHelper.updateMatrixWorld(true);
                renderer.render(scene, camera);

                if (onFrame) onFrame(k);

                if (t < 1) {
                    _animRAF = requestAnimationFrame(frame);
                } else {
                    _animRAF = null;
                    _animCancel = null;
                }
            }

            _animRAF = requestAnimationFrame(frame);
        }

        // ====== Tunables ======
        const TOL = 5e-3;     // 0.5% tolerance for W/H
        const EPS = 1e-10;    // denom near-zero threshold
        const MAX_TRIES = 200;

        // Try random rotations until we get a valid one
        function pickValidRotationAndSolve(t) {
            for (let i = 0; i < MAX_TRIES; i++) {
                randomYawPitch();

                // apply rotation
                mesh.rotation.set(deg2rad(AABBParams.pitch), deg2rad(AABBParams.yaw), 0, 'XYZ');
                mesh.updateMatrixWorld(true);

                // get |R| entries
                const R = getAbsR01(mesh);

                // closed-form solve
                const { hx, A, B, denom } = solveHxForWH(t, R);
                denOut.textContent = denom.toFixed(9);

                if (Math.abs(denom) < EPS) {
                    // width doesn't affect ratio here; check if already satisfied
                    const WH_noWidth = A / B;
                    const rel = Math.abs(WH_noWidth - t) / t;
                    if (rel < TOL) {
                        // Accept without changing width
                        mesh.scale.set(1, 1, 1);
                        mesh.updateMatrixWorld(true);

                        // UI outputs
                        hxOut.textContent = '（任意）';
                        widthOut.textContent = '（任意）';
                        whOut.textContent = WH_noWidth.toFixed(9);
                        err1Out.textContent = (rel * 100).toFixed(6) + '%';
                        msg.innerHTML = '<span class="ok">分母≈0，但该姿态本来就满足目标，无需改宽。</span>';
                        return true;
                    }
                    // otherwise try another rotation
                    continue;
                }

                // Need a positive, finite hx
                if (!(isFinite(hx) && hx > 0)) {
                    continue;
                }

                // apply width (initial half-width = 2 ⇒ scale.x = hx/2)
                const width = 2 * hx;
                mesh.scale.set(hx / 2, 1, 1);
                mesh.updateMatrixWorld(true);

                // check via formula
                const wh_formula = recomputeWH_byFormula(hx, R);
                const err1 = Math.abs(wh_formula - t) / t;

                // accept if within tolerance
                if (err1 < TOL) {
                    hxOut.textContent = hx.toFixed(9);
                    widthOut.textContent = width.toFixed(9);
                    whOut.textContent = wh_formula.toFixed(9);
                    err1Out.textContent = (err1 * 100).toFixed(6) + '%';
                    msg.innerHTML = '<span class="ok">OK：公式回算已在 0.5% 内。</span>';
                    return true;
                }

                // otherwise keep trying
            }

            // If we exit the loop, no valid rotation found
            msg.innerHTML = `<span class="warn">尝试 ${MAX_TRIES} 次仍未命中容差；请调整目标比例或放宽 TOL。</span>`;
            return false;
        }

        function randomAndSolve() {

            if (info) {
                info.setText("Ready");
                info.setType('idle');
            }

            const t = parseRatio(AABBParams.targetRatio);
            if (!isFinite(t) || t <= 0) {
                msg.innerHTML = '<span class="err">比例无效。</span>';
                return;
            }

            // Try until valid
            const ok = pickValidRotationAndSolve(t);
            if (!ok) return;

            // === After we have a valid pose+width, continue your pipeline ===
            rebuildStrips();

            // Update world AABB & helper
            poseGroup.updateMatrixWorld(true);
            mesh.updateMatrixWorld(true);
            worldBox.setFromObject(mesh);
            boxHelper.box.copy(worldBox);
            boxHelper.updateMatrixWorld(true);

            // Fit camera so on-screen AABB width is fixed (e.g., 480 px)
            const measuredAfter = runPoseAndZoomAnimation({
                worldBox,
                camera,
                overlayCanvas: overlay,
                targetPx: TARGET_W_PX,
                startFactor: 0.5,
                clamp: [0.1, 5000],
                zoomBehavior: 'animate',
                rotationOpts: {}
            });


            if (measuredAfter) {
                wh2Out.textContent = measuredAfter.wh.toFixed(9);
                err2Out.textContent = (Math.abs(measuredAfter.wh - t) / t * 100).toFixed(6) + '%';
            }

            render();
        }

        applyAndSolve();

        //====================strip functions start====================

        function worldVertex(geometry, i, mesh) {
            return new THREE.Vector3().fromBufferAttribute(geometry.attributes.position, i).applyMatrix4(mesh.matrixWorld);
        }

        // Quad builder with UVs
        function makeQuad(p0, p1, p2, p3, material) {
            const g = new THREE.BufferGeometry();
            g.setAttribute(
                'position',
                new THREE.Float32BufferAttribute([
                    p0.x, p0.y, p0.z,
                    p1.x, p1.y, p1.z,
                    p2.x, p2.y, p2.z,
                    p3.x, p3.y, p3.z
                ], 3)
            );
            // assume points are ordered around the perimeter (p0->p1->p2->p3)
            g.setIndex([0, 1, 2, 0, 2, 3]);
            g.setAttribute('uv', new THREE.Float32BufferAttribute([0, 0, 1, 0, 1, 1, 0, 1], 2));
            g.computeVertexNormals();
            g.computeBoundingSphere();
            return new THREE.Mesh(g, material);
        }

        // Build a “strip” from segment A->B with a single offset vector
        function makeStrip(A, B, offset, material) {
            return makeQuad(
                A.clone(),                   // p0
                B.clone(),                   // p1
                B.clone().add(offset),       // p2
                A.clone().add(offset),       // p3
                material
            );
        }

        // Build strips those offset applied in opposite dirs
        function makeCenteredStrip(A, B, offset, material) {
            return makeQuad(
                A.clone(),   // p0
                A.clone().add(offset),   // p3
                B.clone(),   // p1
                B.clone().sub(offset),   // p2
                material
            );
        }

        // Remove old strips safely
        function ensureKGroup() {
            if (!kGroup) {
                kGroup = new THREE.Group();
                poseGroup.add(kGroup);              // kGroup is a top-level node the animator rotates
            }
        }

        // clear children but keep kGroup (so its rotation is preserved)
        function clearStrips() {
            if (!kGroup) return;
            for (let i = kGroup.children.length - 1; i >= 0; i--) {
                const m = kGroup.children[i];
                kGroup.remove(m);
                m.geometry?.dispose();
            }
        }

        function rebuildStrips() {
            if (!geo || !mesh) return;

            ensureKGroup();

            mesh.updateMatrixWorld(true);

            // --- define all the points explicitly (world space) ---
            const vStart1 = worldVertex(geo, 5, mesh);
            const vEnd1 = worldVertex(geo, 7, mesh);

            const vStart2 = worldVertex(geo, 1, mesh);
            const vEnd2 = vStart1.clone().add(vEnd1).multiplyScalar(0.5);

            const t = 0.1;
            const vStart3 = vEnd2.clone().lerp(vStart2, t);
            const v2 = worldVertex(geo, 2, mesh);

            // === 关键改动：用“局部轴 → 世界方向”的偏移量 ===
            const qWorld = new THREE.Quaternion();
            mesh.getWorldQuaternion(qWorld);

            // 局部 X、Y 轴旋转到世界（都是单位方向）
            const ex = new THREE.Vector3(1, 0, 0).applyQuaternion(qWorld); // mesh 的 X 轴（世界方向）
            const ey = new THREE.Vector3(0, 1, 0).applyQuaternion(qWorld); // mesh 的 Y 轴（世界方向）

            // 乘上标量得到世界偏移向量（不会被 mesh.scale 放大/缩小）
            const xOffset = ex.clone().multiplyScalar(boxParams.kStroke);
            const yOffsetPos = ey.clone().multiplyScalar(boxParams.kStroke);
            const yOffsetNeg = ey.clone().multiplyScalar(-boxParams.kStroke);

            // --- rebuild the three strips inside kGroup ---
            clearStrips();

            const s1 = makeStrip(vStart1, vEnd1, xOffset, matWhiteDS);  // ← 现在跟着 mesh 的 X 轴走
            const s2 = makeStrip(vStart2, vEnd2, yOffsetNeg, matWhiteDS);  // ← 跟着 mesh 的 Y 轴走
            const s3 = makeCenteredStrip(v2, vStart3, yOffsetPos, matWhiteDS);

            addOutline(s1); addOutline(s2); addOutline(s3);

            s1.material.depthWrite = false;
            s2.material.depthWrite = false;
            s1.renderOrder = 0;
            s2.renderOrder = 1;

            kGroup.add(s1, s2, s3);

            strip1 = s1; strip2 = s2; strip3 = s3;

            render();
        }


        function addOutline(strip, alwaysOnTop = true) {
            const edges = new THREE.EdgesGeometry(strip.geometry, 1); // 1° threshold

            // Make the outline always visible on top:
            if (alwaysOnTop) {
                matLine.depthTest = false;   // ignore depth test
                matLine.depthWrite = false;   // don't write to depth
            }

            const lines = new THREE.LineSegments(edges, matLine);
            lines.renderOrder = (strip.renderOrder || 0) + 10; // draw after the fill
            strip.add(lines); // parent so it follows transforms
            return lines;
        }
        //====================strip functions end====================
        //====================render functions start====================

        let currentRenderer = 'WebGL (Video Output)'; // or 'SVG'

        function createRenderer(kind) {
            if (kind === 'SVG (SVG Output)') {
                const r = new SVGRenderer();
                r.setSize(window.innerWidth, window.innerHeight);
                return r;
            } else {
                const r = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                r.setPixelRatio(window.devicePixelRatio);
                r.setSize(window.innerWidth, window.innerHeight);
                return r;
            }
        }

        function switchRenderer(kind) {
            if (kind === currentRenderer) return;

            // remove old canvas/svg
            if (renderer) {
                renderer.domElement?.parentNode?.removeChild(renderer.domElement);
                // WebGLRenderer has dispose; SVGRenderer does not
                if (renderer.dispose) renderer.dispose();
            }

            renderer = createRenderer(kind);
            document.body.appendChild(renderer.domElement);
            currentRenderer = kind;
        }

        //====================render functions end====================

        import {
            getGUI,
            addColorUI,
            addStaticUI,
            addAnimationUI,
            addExportUI,
        } from './gui.js';

        const gui = getGUI();

        const ui = { showBoxHelper: true }; // default on
        gui.add(ui, 'showBoxHelper').name('Box Helper').onChange((v) => {
            if (boxHelper) boxHelper.visible = v;
            render();
        });

        gui.addColor(colorParams, 'cStroke').name('Stroke').onChange(v => {
            box.material.color.set(v);
            setStrokeColor(v);
        });
        gui.add(boxParams, 'kStroke', 0.001, 1, 0.001).name('Stroke Width').onChange((val) => {
            rebuildStrips();
        });
        gui.add(recParams, 'seconds', 0.5, 30, 0.1).name('Animation Seconds');

        const AABBFolder = gui.addFolder('Settings');
        targetCtrl = AABBFolder.add(AABBParams, 'targetRatio').name('Target W/H');
        yawCtrl = AABBFolder.add(AABBParams, 'yaw', -180, 180, 0.01).name('Yaw (°)');
        pitchCtrl = AABBFolder.add(AABBParams, 'pitch', -180, 180, 0.01).name('Pitch (°)');
        AABBFolder.add(AABBParams, 'animation').name('Animation');
        AABBFolder.add(AABBParams, 'duration', 0.1, 2, 0.1).name('Duration (s)');
        AABBFolder.add(AABBParams, 'applyAndSolve').name('Apply Angles');
        AABBFolder.add(AABBParams, 'randomAndSolve').name('Random Rotate');

        function addLabel(targetGuiOrFolder, text = '', type = '') {
            const container = targetGuiOrFolder.domElement.querySelector(':scope .children')
                || targetGuiOrFolder.domElement; // 顶层 gui 也行
            const row = document.createElement('div');
            row.className = `msg ${type}`; // 
            row.textContent = text;
            container.appendChild(row);
            return {
                setText: (t) => { row.textContent = t; },
                setType: (t) => {
                    row.classList.remove('ok', 'err', 'idle');
                    if (t) row.classList.add(t);
                },
                el: row
            };
        }
        info = addLabel(AABBFolder, 'Ready');

        const exportFolder = gui.addFolder('Export');

        const svgFolder = exportFolder.addFolder('SVG');
        svgFolder.add(svgParams, 'filename').name('SVG Filename');
        const exportSvgCtrl = svgFolder.add(svgParams, 'save').name('Save SVG');

        const videoFolder = exportFolder.addFolder('Video');
        videoFolder.addColor(recParams, 'matte').name('Matte Color');

        videoFolder.add(recParams, 'fps', 1, 60, 1).name('Record FPS');
        videoFolder.add(recParams, 'filename').name('Record Filename');
        const exportVideoAnimCtrl = videoFolder.add(comboActions, 'startAnimRecord').name('Start Animation + Record');

        const fileInput = document.getElementById('file');
        const img = document.getElementById('bg');

        let objectUrl = null;

        const api = {
            loadImage() {
                fileInput.click();
            },
            clear() {
                if (objectUrl) {
                    URL.revokeObjectURL(objectUrl);
                    objectUrl = null;
                }
                img.removeAttribute('src');
                img.style.width = '';
                img.style.height = '';
            },
            opacity: 0.5
        };

        const manualFolder = gui.addFolder('Manual');
        manualFolder.add(api, 'loadImage').name('Upload image…');
        manualFolder.add(api, 'clear').name('Clear');
        manualFolder.add(api, 'opacity', 0, 1, 0.1).name('Opacity').onChange(v => {
            img.style.opacity = v;
        });

        function reduceRatio(w, h) {
            const gcd = (a, b) => (b ? gcd(b, a % b) : a);
            const g = gcd(w, h);
            return [Math.round(w / g), Math.round(h / g)];
        }

        fileInput.addEventListener('change', () => {
            const file = fileInput.files[0];
            if (!file) return;

            if (objectUrl) URL.revokeObjectURL(objectUrl);
            objectUrl = URL.createObjectURL(file);

            img.onload = () => {
                const w = img.naturalWidth;
                const h = img.naturalHeight;
                const ratio = w / h;

                const [rw, rh] = reduceRatio(w, h);
                AABBParams.targetRatio = `${rw}:${rh}`;
                targetCtrl.updateDisplay();

                // Landscape or square → width = 80vw; Portrait → height = 80vh
                if (ratio >= 1) {
                    img.style.width = '50vw';
                    img.style.height = 'auto';
                } else {
                    img.style.width = 'auto';
                    img.style.height = '80vh';
                }

                TARGET_W_PX = Math.round(img.getBoundingClientRect().width);
                console.log("TARGET_W_PX", TARGET_W_PX);
            };

            img.src = objectUrl;
            img.style.opacity = api.opacity;

            // Allow uploading the same file again if needed
            fileInput.value = '';
        });

    </script>
</body>

</html>